
Sensor_board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000006ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000063a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000018  00800100  00800100  000006ae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000006ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000006e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a0  00000000  00000000  0000071c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000304e  00000000  00000000  000008bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f5a  00000000  00000000  0000390a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001262  00000000  00000000  00004864  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000374  00000000  00000000  00005ac8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006e2  00000000  00000000  00005e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bc6  00000000  00000000  0000651e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  000070e4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	df c1       	rjmp	.+958    	; 0x3c2 <__vector_1>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	51 c1       	rjmp	.+674    	; 0x2aa <__vector_3>
   8:	65 c1       	rjmp	.+714    	; 0x2d4 <__vector_4>
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	72 c2       	rjmp	.+1252   	; 0x4fe <__vector_12>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>
  1e:	1a c0       	rjmp	.+52     	; 0x54 <__bad_interrupt>
  20:	19 c0       	rjmp	.+50     	; 0x54 <__bad_interrupt>
  22:	18 c0       	rjmp	.+48     	; 0x54 <__bad_interrupt>
  24:	17 c0       	rjmp	.+46     	; 0x54 <__bad_interrupt>
  26:	16 c0       	rjmp	.+44     	; 0x54 <__bad_interrupt>
  28:	15 c0       	rjmp	.+42     	; 0x54 <__bad_interrupt>
  2a:	14 c0       	rjmp	.+40     	; 0x54 <__bad_interrupt>
  2c:	13 c0       	rjmp	.+38     	; 0x54 <__bad_interrupt>
  2e:	12 c0       	rjmp	.+36     	; 0x54 <__bad_interrupt>
  30:	11 c0       	rjmp	.+34     	; 0x54 <__bad_interrupt>
  32:	10 c0       	rjmp	.+32     	; 0x54 <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d2 e0       	ldi	r29, 0x02	; 2
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_clear_bss>:
  40:	21 e0       	ldi	r18, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a8 31       	cpi	r26, 0x18	; 24
  4c:	b2 07       	cpc	r27, r18
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	e2 d1       	rcall	.+964    	; 0x416 <main>
  52:	f1 c2       	rjmp	.+1506   	; 0x636 <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <adx_chip_select>:
#include "ssp.h"


void adx_chip_select(int select_flag)
{
	if (select_flag) {
  56:	89 2b       	or	r24, r25
  58:	11 f4       	brne	.+4      	; 0x5e <adx_chip_select+0x8>
	AVR_GPIO_PORT &= ~_BV(DB_ADX_SS); /* CS low. */
	}
	else {
	AVR_GPIO_PORT |= _BV(DB_ADX_SS); /* CS high. */
  5a:	54 9a       	sbi	0x0a, 4	; 10
  5c:	08 95       	ret


void adx_chip_select(int select_flag)
{
	if (select_flag) {
	AVR_GPIO_PORT &= ~_BV(DB_ADX_SS); /* CS low. */
  5e:	54 98       	cbi	0x0a, 4	; 10
  60:	08 95       	ret

00000062 <n25_chip_select>:
#include "ssp.h"


void n25_chip_select(int select_flag)
{
	if (select_flag) {
  62:	89 2b       	or	r24, r25
  64:	11 f4       	brne	.+4      	; 0x6a <n25_chip_select+0x8>
		AVR_GPIO_PORT &= ~_BV(PORTC6); /* CS low. */
	}
	else {
		AVR_GPIO_PORT |= _BV(PORTC6); /* CS high. */
  66:	56 9a       	sbi	0x0a, 6	; 10
  68:	08 95       	ret


void n25_chip_select(int select_flag)
{
	if (select_flag) {
		AVR_GPIO_PORT &= ~_BV(PORTC6); /* CS low. */
  6a:	56 98       	cbi	0x0a, 6	; 10
  6c:	08 95       	ret

0000006e <mlx_chip_select>:
void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_MLX_SS); /* CS high. */
  6e:	89 2b       	or	r24, r25
  70:	11 f4       	brne	.+4      	; 0x76 <mlx_chip_select+0x8>
  72:	55 9a       	sbi	0x0a, 5	; 10
  74:	08 95       	ret
  76:	55 98       	cbi	0x0a, 5	; 10
  78:	08 95       	ret

0000007a <mlx_sleep>:
	USART_Receive(0);
	mlx_chip_select(0);
}

uint8_t mlx_sleep()
{
  7a:	cf 93       	push	r28


void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
  7c:	55 98       	cbi	0x0a, 5	; 10

uint8_t mlx_sleep()
{
	uint8_t confirm;
	mlx_chip_select(1);
	USART_Receive(MLX_RS);
  7e:	80 ef       	ldi	r24, 0xF0	; 240
  80:	3b d0       	rcall	.+118    	; 0xf8 <USART_Receive>
	USART_Receive(0);
  82:	80 e0       	ldi	r24, 0x00	; 0
  84:	39 d0       	rcall	.+114    	; 0xf8 <USART_Receive>
void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_MLX_SS); /* CS high. */
  86:	55 9a       	sbi	0x0a, 5	; 10


void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
  88:	55 98       	cbi	0x0a, 5	; 10
	USART_Receive(0);
	mlx_chip_select(0);
	/* put MLX in to lowest power, disables WDOG and measurements*/
	/*first make request*/
	mlx_chip_select(1);
	USART_Receive(MLX_RSLP);
  8a:	81 ee       	ldi	r24, 0xE1	; 225
  8c:	35 d0       	rcall	.+106    	; 0xf8 <USART_Receive>
	USART_Receive(0);
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	33 d0       	rcall	.+102    	; 0xf8 <USART_Receive>
void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_MLX_SS); /* CS high. */
  92:	55 9a       	sbi	0x0a, 5	; 10


void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
  94:	55 98       	cbi	0x0a, 5	; 10
	USART_Receive(0);
	mlx_chip_select(0);
	
	/*then confirm*/
	mlx_chip_select(1);
	confirm = USART_Receive(MLX_CSLP);
  96:	83 ea       	ldi	r24, 0xA3	; 163
  98:	2f d0       	rcall	.+94     	; 0xf8 <USART_Receive>
	USART_Receive(0);
  9a:	80 e0       	ldi	r24, 0x00	; 0
  9c:	2d d0       	rcall	.+90     	; 0xf8 <USART_Receive>
void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_MLX_SS); /* CS high. */
  9e:	55 9a       	sbi	0x0a, 5	; 10


void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
  a0:	55 98       	cbi	0x0a, 5	; 10
	USART_Receive(0);
	mlx_chip_select(0);
	
	/*then confirm*/
	mlx_chip_select(1);
	confirm = USART_Receive(MLX_CSLP);
  a2:	83 ea       	ldi	r24, 0xA3	; 163
  a4:	29 d0       	rcall	.+82     	; 0xf8 <USART_Receive>
  a6:	c8 2f       	mov	r28, r24
	USART_Receive(0);
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	26 d0       	rcall	.+76     	; 0xf8 <USART_Receive>
void mlx_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_MLX_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_MLX_SS); /* CS high. */
  ac:	55 9a       	sbi	0x0a, 5	; 10
	confirm = USART_Receive(MLX_CSLP);
	USART_Receive(0);
	mlx_chip_select(0);
	for (int i = 0; i < 16000; i++);
	return confirm;	
  ae:	8c 2f       	mov	r24, r28
  b0:	cf 91       	pop	r28
  b2:	08 95       	ret

000000b4 <spi_usart_setup>:
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_SSP_SS); /* CS high. */
  b4:	89 2b       	or	r24, r25
  b6:	09 f4       	brne	.+2      	; 0xba <spi_usart_setup+0x6>
  b8:	08 95       	ret
  ba:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__EEPROM_REGION_LENGTH__+0x7f00c5>
  be:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__EEPROM_REGION_LENGTH__+0x7f00c4>
  c2:	81 ef       	ldi	r24, 0xF1	; 241
  c4:	89 b9       	out	0x09, r24	; 9
  c6:	82 ec       	ldi	r24, 0xC2	; 194
  c8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__EEPROM_REGION_LENGTH__+0x7f00c2>
  cc:	88 e1       	ldi	r24, 0x18	; 24
  ce:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__EEPROM_REGION_LENGTH__+0x7f00c1>
  d2:	88 e0       	ldi	r24, 0x08	; 8
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__EEPROM_REGION_LENGTH__+0x7f00c5>
  da:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__EEPROM_REGION_LENGTH__+0x7f00c4>
  de:	57 9a       	sbi	0x0a, 7	; 10
  e0:	80 e0       	ldi	r24, 0x00	; 0
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	c4 df       	rcall	.-120    	; 0x6e <mlx_chip_select>
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	b5 df       	rcall	.-150    	; 0x56 <adx_chip_select>
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	b8 cf       	rjmp	.-144    	; 0x62 <n25_chip_select>

000000f2 <ssp_boot>:
  f2:	57 98       	cbi	0x0a, 7	; 10
  f4:	57 9a       	sbi	0x0a, 7	; 10
  f6:	08 95       	ret

000000f8 <USART_Receive>:
  f8:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
  fc:	95 ff       	sbrs	r25, 5
  fe:	fc cf       	rjmp	.-8      	; 0xf8 <USART_Receive>
 100:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 104:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 108:	87 ff       	sbrs	r24, 7
 10a:	fc cf       	rjmp	.-8      	; 0x104 <USART_Receive+0xc>
 10c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 110:	08 95       	ret

00000112 <ssp_setup>:
 112:	57 98       	cbi	0x0a, 7	; 10
 114:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 118:	85 ff       	sbrs	r24, 5
 11a:	fc cf       	rjmp	.-8      	; 0x114 <ssp_setup+0x2>
 11c:	80 e4       	ldi	r24, 0x40	; 64
 11e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 122:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 126:	87 ff       	sbrs	r24, 7
 128:	fc cf       	rjmp	.-8      	; 0x122 <ssp_setup+0x10>
 12a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 12e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 132:	85 ff       	sbrs	r24, 5
 134:	fc cf       	rjmp	.-8      	; 0x12e <ssp_setup+0x1c>
 136:	10 92 c6 00 	sts	0x00C6, r1	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 13a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 13e:	87 ff       	sbrs	r24, 7
 140:	fc cf       	rjmp	.-8      	; 0x13a <ssp_setup+0x28>
 142:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 146:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 14a:	85 ff       	sbrs	r24, 5
 14c:	fc cf       	rjmp	.-8      	; 0x146 <ssp_setup+0x34>
 14e:	81 e6       	ldi	r24, 0x61	; 97
 150:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 154:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 158:	87 ff       	sbrs	r24, 7
 15a:	fc cf       	rjmp	.-8      	; 0x154 <ssp_setup+0x42>
 15c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
 160:	57 9a       	sbi	0x0a, 7	; 10
 162:	08 95       	ret

00000164 <ssp_int_reset>:

void
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
 164:	57 98       	cbi	0x0a, 7	; 10

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 166:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 16a:	85 ff       	sbrs	r24, 5
 16c:	fc cf       	rjmp	.-8      	; 0x166 <ssp_int_reset+0x2>
	/*put data into buffer, sends data */
	UDR = data;
 16e:	81 e4       	ldi	r24, 0x41	; 65
 170:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 174:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 178:	87 ff       	sbrs	r24, 7
 17a:	fc cf       	rjmp	.-8      	; 0x174 <ssp_int_reset+0x10>
	return UDR;
 17c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 180:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 184:	85 ff       	sbrs	r24, 5
 186:	fc cf       	rjmp	.-8      	; 0x180 <ssp_int_reset+0x1c>
	/*put data into buffer, sends data */
	UDR = data;
 188:	80 e1       	ldi	r24, 0x10	; 16
 18a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 18e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 192:	87 ff       	sbrs	r24, 7
 194:	fc cf       	rjmp	.-8      	; 0x18e <ssp_int_reset+0x2a>
	return UDR;
 196:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 19a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 19e:	85 ff       	sbrs	r24, 5
 1a0:	fc cf       	rjmp	.-8      	; 0x19a <ssp_int_reset+0x36>
	/*put data into buffer, sends data */
	UDR = data;
 1a2:	10 92 c6 00 	sts	0x00C6, r1	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 1a6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1aa:	87 ff       	sbrs	r24, 7
 1ac:	fc cf       	rjmp	.-8      	; 0x1a6 <ssp_int_reset+0x42>
	return UDR;
 1ae:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_SSP_SS); /* CS high. */
 1b2:	57 9a       	sbi	0x0a, 7	; 10
 1b4:	08 95       	ret

000001b6 <ssp_read_byte>:

void
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
 1b6:	57 98       	cbi	0x0a, 7	; 10

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 1b8:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1bc:	85 ff       	sbrs	r24, 5
 1be:	fc cf       	rjmp	.-8      	; 0x1b8 <ssp_read_byte+0x2>
	/*put data into buffer, sends data */
	UDR = data;
 1c0:	81 e4       	ldi	r24, 0x41	; 65
 1c2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 1c6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1ca:	87 ff       	sbrs	r24, 7
 1cc:	fc cf       	rjmp	.-8      	; 0x1c6 <ssp_read_byte+0x10>
	return UDR;
 1ce:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 1d2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1d6:	85 ff       	sbrs	r24, 5
 1d8:	fc cf       	rjmp	.-8      	; 0x1d2 <ssp_read_byte+0x1c>
	/*put data into buffer, sends data */
	UDR = data;
 1da:	8e e0       	ldi	r24, 0x0E	; 14
 1dc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 1e0:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1e4:	87 ff       	sbrs	r24, 7
 1e6:	fc cf       	rjmp	.-8      	; 0x1e0 <ssp_read_byte+0x2a>
	return UDR;
 1e8:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 1ec:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1f0:	85 ff       	sbrs	r24, 5
 1f2:	fc cf       	rjmp	.-8      	; 0x1ec <ssp_read_byte+0x36>
	/*put data into buffer, sends data */
	UDR = data;
 1f4:	10 92 c6 00 	sts	0x00C6, r1	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 1f8:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 1fc:	87 ff       	sbrs	r24, 7
 1fe:	fc cf       	rjmp	.-8      	; 0x1f8 <ssp_read_byte+0x42>
	return UDR;
 200:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_SSP_SS); /* CS high. */
 204:	57 9a       	sbi	0x0a, 7	; 10
	USART_Receive(SSP_READ);
	USART_Receive(INTFA);
	temp = USART_Receive(0x00);
	ssp_chip_select(0);
	return temp;
}
 206:	08 95       	ret

00000208 <ssp_write>:

void
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
 208:	57 98       	cbi	0x0a, 7	; 10

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 20a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 20e:	95 ff       	sbrs	r25, 5
 210:	fc cf       	rjmp	.-8      	; 0x20a <ssp_write+0x2>
	/*put data into buffer, sends data */
	UDR = data;
 212:	90 e4       	ldi	r25, 0x40	; 64
 214:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 218:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 21c:	97 ff       	sbrs	r25, 7
 21e:	fc cf       	rjmp	.-8      	; 0x218 <ssp_write+0x10>
	return UDR;
 220:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 224:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 228:	95 ff       	sbrs	r25, 5
 22a:	fc cf       	rjmp	.-8      	; 0x224 <ssp_write+0x1c>
	/*put data into buffer, sends data */
	UDR = data;
 22c:	92 e1       	ldi	r25, 0x12	; 18
 22e:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 232:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 236:	97 ff       	sbrs	r25, 7
 238:	fc cf       	rjmp	.-8      	; 0x232 <ssp_write+0x2a>
	return UDR;
 23a:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 23e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 242:	95 ff       	sbrs	r25, 5
 244:	fc cf       	rjmp	.-8      	; 0x23e <ssp_write+0x36>
	/*put data into buffer, sends data */
	UDR = data;
 246:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 24a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 24e:	97 ff       	sbrs	r25, 7
 250:	fc cf       	rjmp	.-8      	; 0x24a <ssp_write+0x42>
	return UDR;
 252:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_SSP_SS); /* CS high. */
 256:	57 9a       	sbi	0x0a, 7	; 10

void
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
 258:	57 98       	cbi	0x0a, 7	; 10

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 25a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 25e:	95 ff       	sbrs	r25, 5
 260:	fc cf       	rjmp	.-8      	; 0x25a <ssp_write+0x52>
	/*put data into buffer, sends data */
	UDR = data;
 262:	90 e4       	ldi	r25, 0x40	; 64
 264:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 268:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 26c:	97 ff       	sbrs	r25, 7
 26e:	fc cf       	rjmp	.-8      	; 0x268 <ssp_write+0x60>
	return UDR;
 270:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 274:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 278:	95 ff       	sbrs	r25, 5
 27a:	fc cf       	rjmp	.-8      	; 0x274 <ssp_write+0x6c>
	/*put data into buffer, sends data */
	UDR = data;
 27c:	94 e1       	ldi	r25, 0x14	; 20
 27e:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 282:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 286:	97 ff       	sbrs	r25, 7
 288:	fc cf       	rjmp	.-8      	; 0x282 <ssp_write+0x7a>
	return UDR;
 28a:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>

uint8_t
USART_Receive (uint8_t data)
{
	/* wait for empty transmit buffer */
	while (!(UCSRA & (1<<UDRE)));
 28e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 292:	95 ff       	sbrs	r25, 5
 294:	fc cf       	rjmp	.-8      	; 0x28e <ssp_write+0x86>
	/*put data into buffer, sends data */
	UDR = data;
 296:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
	/*wait for the data to be received */
	while (!(UCSRA & (1<<RXC)));
 29a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__EEPROM_REGION_LENGTH__+0x7f00c0>
 29e:	87 ff       	sbrs	r24, 7
 2a0:	fc cf       	rjmp	.-8      	; 0x29a <ssp_write+0x92>
	return UDR;
 2a2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
ssp_chip_select(int select_flag)
{
	if (select_flag)
	AVR_GPIO_PORT &= ~_BV(DB_SSP_SS); /* CS low. */
	else
	AVR_GPIO_PORT |= _BV(DB_SSP_SS); /* CS high. */
 2a6:	57 9a       	sbi	0x0a, 7	; 10
 2a8:	08 95       	ret

000002aa <__vector_3>:
/* Interrupts         */
/* Tamper protection. */
#if 1
/* Interrupt handler for panic switch. */
ISR (PCINT0_vect)
{
 2aa:	1f 92       	push	r1
 2ac:	0f 92       	push	r0
 2ae:	0f b6       	in	r0, 0x3f	; 63
 2b0:	0f 92       	push	r0
 2b2:	11 24       	eor	r1, r1
 2b4:	cf 93       	push	r28
 2b6:	df 93       	push	r29
 2b8:	00 d0       	rcall	.+0      	; 0x2ba <__vector_3+0x10>
 2ba:	cd b7       	in	r28, 0x3d	; 61
 2bc:	de b7       	in	r29, 0x3e	; 62
volatile int i =0;
 2be:	1a 82       	std	Y+2, r1	; 0x02
 2c0:	19 82       	std	Y+1, r1	; 0x01
}
 2c2:	0f 90       	pop	r0
 2c4:	0f 90       	pop	r0
 2c6:	df 91       	pop	r29
 2c8:	cf 91       	pop	r28
 2ca:	0f 90       	pop	r0
 2cc:	0f be       	out	0x3f, r0	; 63
 2ce:	0f 90       	pop	r0
 2d0:	1f 90       	pop	r1
 2d2:	18 95       	reti

000002d4 <__vector_4>:

/* soft-UART RX */
#if 1
/* Detection of start bit */
ISR (PCINT1_vect)
{
 2d4:	1f 92       	push	r1
 2d6:	0f 92       	push	r0
 2d8:	0f b6       	in	r0, 0x3f	; 63
 2da:	0f 92       	push	r0
 2dc:	11 24       	eor	r1, r1
 2de:	8f 93       	push	r24
 2e0:	9f 93       	push	r25
 2e2:	ef 93       	push	r30
 2e4:	ff 93       	push	r31
		a.) 10 bit character is received or
		b.) we have a 10 bit timeout
	2. reload bit counter
	3. set timer A0 for a half-bit timer*/
	//PCMSK1 &= ~_BV(PCINT10); //was
	TCNT0 = 0x00;
 2e6:	16 bc       	out	0x26, r1	; 38
	PCMSK1 &= ~_BV(PCINT11);
 2e8:	ec e6       	ldi	r30, 0x6C	; 108
 2ea:	f0 e0       	ldi	r31, 0x00	; 0
 2ec:	80 81       	ld	r24, Z
 2ee:	87 7f       	andi	r24, 0xF7	; 247
 2f0:	80 83       	st	Z, r24
	//PCICR &= ~_BV(PCIE1);
	//PCIFR |= _BV(PCIF1);
	start_bit = 1;
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <start_bit>
	rcv_bit_count = 9;   // TBD 7 or 8? look for the stop bit?
 2f8:	99 e0       	ldi	r25, 0x09	; 9
 2fa:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <rcv_bit_count>
	rcv_char = 0x00; //flush receive buffer
 2fe:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <rcv_char>
	receiving = 1;
 302:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <receiving>
	//OCR0A = 208;						// 208us compare value for 4800 baud
	
	TIMSK0 |= (1<<OCIE0A);              //if you want interrupt
 306:	ee e6       	ldi	r30, 0x6E	; 110
 308:	f0 e0       	ldi	r31, 0x00	; 0
 30a:	80 81       	ld	r24, Z
 30c:	82 60       	ori	r24, 0x02	; 2
 30e:	80 83       	st	Z, r24
	//PORTC ^= _BV(PORTC6);
}
 310:	ff 91       	pop	r31
 312:	ef 91       	pop	r30
 314:	9f 91       	pop	r25
 316:	8f 91       	pop	r24
 318:	0f 90       	pop	r0
 31a:	0f be       	out	0x3f, r0	; 63
 31c:	0f 90       	pop	r0
 31e:	1f 90       	pop	r1
 320:	18 95       	reti

00000322 <mkm_wipe>:
}

/*static inline*/ void
mkm_wipe()
{
  AVR_LED_PORT |= _BV(AVR_LED_RED_BIT);
 322:	13 9a       	sbi	0x02, 3	; 2
spi_setup(int on_flag)
{
  if (on_flag)
    {
      /* Disable SPI power reduction. */
      PRR &= ~_BV(PRSPI);
 324:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <__EEPROM_REGION_LENGTH__+0x7f0064>
 328:	8b 7f       	andi	r24, 0xFB	; 251
 32a:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__EEPROM_REGION_LENGTH__+0x7f0064>

      /* Configure MOSI and SCK pins as output. */
      DDRD = _BV(MKM_AVR_MOSI_BIT) | _BV(MKM_AVR_SCK_BIT);
 32e:	89 e0       	ldi	r24, 0x09	; 9
 330:	8d b9       	out	0x0d, r24	; 13

      /* Make sure SPI slave select (SS) is configured as output
         before enabling SPI master mode! */
      DDRC |= _BV(SPI_SS);  //MAD WTF? this is not the GPIO port......
 332:	48 9a       	sbi	0x09, 0	; 9

      /* Enable SPI in master mode, clock rate f/16. */
      SPCR = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 334:	81 e5       	ldi	r24, 0x51	; 81
 336:	8c bd       	out	0x2c, r24	; 44
	  
	  MKM_CS_PORT |= _BV(MKM_CS_BIT); /* CS high. */
 338:	15 9a       	sbi	0x02, 5	; 2
}

static inline void
mkm_grab()
{
  MKM_CONTROL_FPGA_PORT |= _BV(MKM_CONTROL_FPGA_BIT);
 33a:	17 9a       	sbi	0x02, 7	; 2
  MKM_CONTROL_AVR_PORT &= ~_BV(MKM_CONTROL_AVR_BIT);
 33c:	16 98       	cbi	0x02, 6	; 2
/* MKM */
static inline void
mkm_chip_select(int select_flag)
{
  if (select_flag)
    MKM_CS_PORT &= ~_BV(MKM_CS_BIT); /* CS low. */
 33e:	15 98       	cbi	0x02, 5	; 2
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 340:	81 e0       	ldi	r24, 0x01	; 1
 342:	8e bd       	out	0x2e, r24	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 344:	0d b4       	in	r0, 0x2d	; 45
 346:	07 fe       	sbrs	r0, 7
 348:	fd cf       	rjmp	.-6      	; 0x344 <mkm_wipe+0x22>
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 34a:	80 e4       	ldi	r24, 0x40	; 64
 34c:	8e bd       	out	0x2e, r24	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 34e:	0d b4       	in	r0, 0x2d	; 45
 350:	07 fe       	sbrs	r0, 7
 352:	fd cf       	rjmp	.-6      	; 0x34e <mkm_wipe+0x2c>
mkm_chip_select(int select_flag)
{
  if (select_flag)
    MKM_CS_PORT &= ~_BV(MKM_CS_BIT); /* CS low. */
  else
    MKM_CS_PORT |= _BV(MKM_CS_BIT); /* CS high. */
 354:	15 9a       	sbi	0x02, 5	; 2
/* MKM */
static inline void
mkm_chip_select(int select_flag)
{
  if (select_flag)
    MKM_CS_PORT &= ~_BV(MKM_CS_BIT); /* CS low. */
 356:	15 98       	cbi	0x02, 5	; 2
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 358:	82 e0       	ldi	r24, 0x02	; 2
 35a:	8e bd       	out	0x2e, r24	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 35c:	0d b4       	in	r0, 0x2d	; 45
 35e:	07 fe       	sbrs	r0, 7
 360:	fd cf       	rjmp	.-6      	; 0x35c <mkm_wipe+0x3a>
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 362:	1e bc       	out	0x2e, r1	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 364:	0d b4       	in	r0, 0x2d	; 45
 366:	07 fe       	sbrs	r0, 7
 368:	fd cf       	rjmp	.-6      	; 0x364 <mkm_wipe+0x42>
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 36a:	1e bc       	out	0x2e, r1	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 36c:	0d b4       	in	r0, 0x2d	; 45
 36e:	07 fe       	sbrs	r0, 7
 370:	fd cf       	rjmp	.-6      	; 0x36c <mkm_wipe+0x4a>
 372:	8f ef       	ldi	r24, 0xFF	; 255
 374:	9f e1       	ldi	r25, 0x1F	; 31
static inline void
spi_write(uint8_t val)
{
  /* Move the value to be sent to the SPI slave into the SPI
     register. This starts the SPI clock. */
  SPDR = val;
 376:	1e bc       	out	0x2e, r1	; 46

  /* Wait for the byte to be shifted into the slave. */
  loop_until_bit_is_set(SPSR, SPIF);
 378:	0d b4       	in	r0, 0x2d	; 45
 37a:	07 fe       	sbrs	r0, 7
 37c:	fd cf       	rjmp	.-6      	; 0x378 <mkm_wipe+0x56>
 37e:	01 97       	sbiw	r24, 0x01	; 1

  mkm_chip_select(1);
  spi_write(SPI_WRITE);
  spi_write(0);                    /* Address, high byte. */
  spi_write(0);                    /* Address, low byte. */
  for (int i = 0; i < 0x1fff; i++) /* 8192 bytes (64Kbit). */
 380:	d1 f7       	brne	.-12     	; 0x376 <mkm_wipe+0x54>
mkm_chip_select(int select_flag)
{
  if (select_flag)
    MKM_CS_PORT &= ~_BV(MKM_CS_BIT); /* CS low. */
  else
    MKM_CS_PORT |= _BV(MKM_CS_BIT); /* CS high. */
 382:	15 9a       	sbi	0x02, 5	; 2
}

static inline void
mkm_release()
{
  MKM_CONTROL_AVR_PORT |= _BV(MKM_CONTROL_AVR_BIT);
 384:	16 9a       	sbi	0x02, 6	; 2
  MKM_CONTROL_FPGA_PORT &= ~_BV(MKM_CONTROL_FPGA_BIT);
 386:	17 98       	cbi	0x02, 7	; 2
	  
	  MKM_CS_PORT |= _BV(MKM_CS_BIT); /* CS high. */
    }
  else
    {
      SPCR &= ~_BV(SPE);        /* Disable SPI. */
 388:	8c b5       	in	r24, 0x2c	; 44
 38a:	8f 7b       	andi	r24, 0xBF	; 191
 38c:	8c bd       	out	0x2c, r24	; 44
      PRR |= _BV(PRSPI);        /* Enable SPI power reduction. */
 38e:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <__EEPROM_REGION_LENGTH__+0x7f0064>
 392:	84 60       	ori	r24, 0x04	; 4
 394:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__EEPROM_REGION_LENGTH__+0x7f0064>
  mkm_chip_select(0);

  mkm_release();
  spi_setup(0);

  AVR_LED_PORT &= ~_BV(AVR_LED_RED_BIT);
 398:	13 98       	cbi	0x02, 3	; 2

  /* Flash blue LED three times to indicate wipe is done */
  for (int x = 0; x < 6; x++) {
    AVR_LED_PORT ^= _BV(AVR_LED_BLUE_BIT);
 39a:	92 b1       	in	r25, 0x02	; 2
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	98 27       	eor	r25, r24
 3a0:	92 b9       	out	0x02, r25	; 2
 3a2:	92 b1       	in	r25, 0x02	; 2
 3a4:	98 27       	eor	r25, r24
 3a6:	92 b9       	out	0x02, r25	; 2
 3a8:	92 b1       	in	r25, 0x02	; 2
 3aa:	98 27       	eor	r25, r24
 3ac:	92 b9       	out	0x02, r25	; 2
 3ae:	92 b1       	in	r25, 0x02	; 2
 3b0:	98 27       	eor	r25, r24
 3b2:	92 b9       	out	0x02, r25	; 2
 3b4:	92 b1       	in	r25, 0x02	; 2
 3b6:	98 27       	eor	r25, r24
 3b8:	92 b9       	out	0x02, r25	; 2
 3ba:	92 b1       	in	r25, 0x02	; 2
 3bc:	89 27       	eor	r24, r25
 3be:	82 b9       	out	0x02, r24	; 2
 3c0:	08 95       	ret

000003c2 <__vector_1>:
#endif

#if 1
/* Interrupt handler for case tamper switches. */
ISR (INT0_vect)
{
 3c2:	1f 92       	push	r1
 3c4:	0f 92       	push	r0
 3c6:	0f b6       	in	r0, 0x3f	; 63
 3c8:	0f 92       	push	r0
 3ca:	11 24       	eor	r1, r1
 3cc:	2f 93       	push	r18
 3ce:	3f 93       	push	r19
 3d0:	4f 93       	push	r20
 3d2:	5f 93       	push	r21
 3d4:	6f 93       	push	r22
 3d6:	7f 93       	push	r23
 3d8:	8f 93       	push	r24
 3da:	9f 93       	push	r25
 3dc:	af 93       	push	r26
 3de:	bf 93       	push	r27
 3e0:	ef 93       	push	r30
 3e2:	ff 93       	push	r31
	/*disable interrupts until memory is cleared */

	cli();
 3e4:	f8 94       	cli
	mkm_wipe();
 3e6:	9d df       	rcall	.-198    	; 0x322 <mkm_wipe>
	/*TAMP_ON turns on LED and provides falling edge signal to Pi to indicate tamper event */
	ssp_write(TAMP_ON);
 3e8:	88 e0       	ldi	r24, 0x08	; 8
 3ea:	0e df       	rcall	.-484    	; 0x208 <ssp_write>
	ssp_int_reset();   /*read INTFA reg to reset flag*/
 3ec:	bb de       	rcall	.-650    	; 0x164 <ssp_int_reset>
}

static inline void
mkm_grab()
{
  MKM_CONTROL_FPGA_PORT |= _BV(MKM_CONTROL_FPGA_BIT);
 3ee:	17 9a       	sbi	0x02, 7	; 2
  MKM_CONTROL_AVR_PORT &= ~_BV(MKM_CONTROL_AVR_BIT);
 3f0:	16 98       	cbi	0x02, 6	; 2
	mkm_wipe();
	/*TAMP_ON turns on LED and provides falling edge signal to Pi to indicate tamper event */
	ssp_write(TAMP_ON);
	ssp_int_reset();   /*read INTFA reg to reset flag*/
	mkm_grab();		   /*prevents FPGA from accessing MKM */
	sei();				/* re-enabling interrupts allows additional tamper trigger or tamper reset */
 3f2:	78 94       	sei
	//sleep_disable();
}
 3f4:	ff 91       	pop	r31
 3f6:	ef 91       	pop	r30
 3f8:	bf 91       	pop	r27
 3fa:	af 91       	pop	r26
 3fc:	9f 91       	pop	r25
 3fe:	8f 91       	pop	r24
 400:	7f 91       	pop	r23
 402:	6f 91       	pop	r22
 404:	5f 91       	pop	r21
 406:	4f 91       	pop	r20
 408:	3f 91       	pop	r19
 40a:	2f 91       	pop	r18
 40c:	0f 90       	pop	r0
 40e:	0f be       	out	0x3f, r0	; 63
 410:	0f 90       	pop	r0
 412:	1f 90       	pop	r1
 414:	18 95       	reti

00000416 <main>:
static inline void
init_ports()
{
  /* Configure all PORTA pins except the tamper detection pin as
     outputs. */
  DDRA = 0xff & ~_BV(AVR_PANIC_BIT);
 416:	8f ee       	ldi	r24, 0xEF	; 239
 418:	81 b9       	out	0x01, r24	; 1
  //DDRB = 0xff & ~_BV(PINB3);
  //DDRB = 0xff & ~_BV(PINB2);
	DDRB = 0xf7; //was fb
 41a:	87 ef       	ldi	r24, 0xF7	; 247
 41c:	85 b9       	out	0x05, r24	; 5

static void
init_interrupts()
{
  //PCICR |= _BV(PCIE0|PCIE2);    /* Enable pin change interrupt on PCMSK0 & PCMSK2*/
  PCICR = (1<<PCIE0)|(1<<PCIE1)|(1<<PCIE2);
 41e:	27 e0       	ldi	r18, 0x07	; 7
 420:	20 93 68 00 	sts	0x0068, r18	; 0x800068 <__EEPROM_REGION_LENGTH__+0x7f0068>
  PCMSK0 |= _BV(PCINT4);        /* Set mask bit for PCINT4 (panic) */
 424:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <__EEPROM_REGION_LENGTH__+0x7f006b>
 428:	80 61       	ori	r24, 0x10	; 16
 42a:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <__EEPROM_REGION_LENGTH__+0x7f006b>
  /*setup PC6 as tamper disable */
  //PUEC = (1<<PUEC6);			/*enable internal pull-up to avoid false triggers */ 
  PORTC |= (1<<PORTC6);
 42e:	56 9a       	sbi	0x0a, 6	; 10
  //PCMSK2 |= _BV(PCINT22);
  /*setup PB2 as soft-UART RX*/
  //PUEB = (1<<PUEB3) | (1<<PUEB2);			/*enable internal pull-up to detect start bit */
  PUEB = (1<<PUEB3);
 430:	98 e0       	ldi	r25, 0x08	; 8
 432:	97 b9       	out	0x07, r25	; 7
  PCMSK1 |= _BV(PCINT11);
 434:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
 438:	88 60       	ori	r24, 0x08	; 8
 43a:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
 // PCMSK1 |= _BV(PCINT10);
  sei();
 43e:	78 94       	sei
{
  init_ports();
  init_power_reduction();
  init_interrupts();
  uint8_t ssp_status = 0;
  sending = 0;
 440:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <sending>
  receiving = 0;
 444:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <receiving>
  tx_char = 0;
 448:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <tx_char>
  tx_bit_count = 0;
 44c:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <tx_bit_count>
  PORTB |= _BV(PORTB3);   //set TX idle high
 450:	33 9a       	sbi	0x06, 3	; 6
  wd_init = 0x01;
 452:	81 e0       	ldi	r24, 0x01	; 1
 454:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <wd_init>
  ssp_out = WDOG_RS;
 458:	30 e1       	ldi	r19, 0x10	; 16
 45a:	30 93 01 01 	sts	0x0101, r19	; 0x800101 <ssp_out>
  PORTC |= _BV(PORTC6);
 45e:	56 9a       	sbi	0x0a, 6	; 10
  TCNT0 = 0x00;
 460:	16 bc       	out	0x26, r1	; 38
  TCCR0A = (1<<COM0A1) | (1 << WGM01);             //CTC mode
 462:	32 e8       	ldi	r19, 0x82	; 130
 464:	34 bd       	out	0x24, r19	; 36
  TCCR0B = (1 << CS00);              //div1
 466:	85 bd       	out	0x25, r24	; 37
  OCR0A = 180;						// 208us compare value for 4800 baud
 468:	84 eb       	ldi	r24, 0xB4	; 180
 46a:	87 bd       	out	0x27, r24	; 39
  rcv[0]= 0xff;
 46c:	8f ef       	ldi	r24, 0xFF	; 255
 46e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <rcv>
  rcv[1] = 0x02;
 472:	82 e0       	ldi	r24, 0x02	; 2
 474:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <rcv+0x1>
  rcv[2] = 0x03;
 478:	83 e0       	ldi	r24, 0x03	; 3
 47a:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <rcv+0x2>
  rcv[3] = 0x04;
 47e:	84 e0       	ldi	r24, 0x04	; 4
 480:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <rcv+0x3>
  rcv[4] = 0x05;
 484:	85 e0       	ldi	r24, 0x05	; 5
 486:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <rcv+0x4>
  rcv[5]= 0x06;
 48a:	86 e0       	ldi	r24, 0x06	; 6
 48c:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <rcv+0x5>
  rcv[6] = 0x07;
 490:	20 93 14 01 	sts	0x0114, r18	; 0x800114 <rcv+0x6>
  rcv[7] = 0x08;
 494:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <rcv+0x7>
  rcv[8]= 0x09;
 498:	89 e0       	ldi	r24, 0x09	; 9
 49a:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <rcv+0x8>
  spi_usart_setup(1);
 49e:	81 e0       	ldi	r24, 0x01	; 1
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	08 de       	rcall	.-1008   	; 0xb4 <spi_usart_setup>
  mlx_sleep();
  //ensure that adx is also at low power mode

  adx_wr_reg(ADX_POWER_CTL, 0x00);
  adx_rd_reg(ADX_STATUS);*/
  ssp_boot();
 4a4:	26 de       	rcall	.-948    	; 0xf2 <ssp_boot>
  //ssp_read_byte();
  //setup directions for ssp pins
  ssp_setup();
 4a6:	35 de       	rcall	.-918    	; 0x112 <ssp_setup>
  //cycle the TAMP_CLR to reset the relays and turn of LEDS
  //to save power. Keep WDOG signal in high state
  ssp_write(ssp_out|0x02);
 4a8:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <ssp_out>
 4ac:	82 60       	ori	r24, 0x02	; 2
 4ae:	ac de       	rcall	.-680    	; 0x208 <ssp_write>
  ssp_write(ssp_out);
 4b0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <ssp_out>
 4b4:	a9 de       	rcall	.-686    	; 0x208 <ssp_write>
  //setup the tamper monitoring input
  //ssp_int_config();
 uint8_t check =  ssp_read_byte();
 4b6:	7f de       	rcall	.-770    	; 0x1b6 <ssp_read_byte>
  //init_int0();
  mlx_sleep();
 4b8:	e0 dd       	rcall	.-1088   	; 0x7a <mlx_sleep>
}

static inline void
mkm_release()
{
  MKM_CONTROL_AVR_PORT |= _BV(MKM_CONTROL_AVR_BIT);
 4ba:	16 9a       	sbi	0x02, 6	; 2
  MKM_CONTROL_FPGA_PORT &= ~_BV(MKM_CONTROL_FPGA_BIT);
 4bc:	17 98       	cbi	0x02, 7	; 2
  
  //initTimer1(TWD_INIT);
  
  mkm_release();
  /* Flash LED's at startup. */
  AVR_LED_PORT |= 0x0f;
 4be:	82 b1       	in	r24, 0x02	; 2
 4c0:	8f 60       	ori	r24, 0x0F	; 15
 4c2:	82 b9       	out	0x02, r24	; 2
  for (int i = 0; i < 16000; i++);
  AVR_LED_PORT &= ~0x0f;
 4c4:	82 b1       	in	r24, 0x02	; 2
 4c6:	80 7f       	andi	r24, 0xF0	; 240
 4c8:	82 b9       	out	0x02, r24	; 2
// go to sleep, interrupt will wake us
  //sleep();
  rcv_valid = 0;
 4ca:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <rcv_valid>
  sei();
 4ce:	78 94       	sei
  while (1)
    {
		//n25_read(0x00, 0x00, 0x00, 8);
		if (rcv_valid ==1){
 4d0:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <rcv_valid>
 4d4:	81 30       	cpi	r24, 0x01	; 1
 4d6:	e1 f7       	brne	.-8      	; 0x4d0 <main+0xba>
			rcv_valid = 0;
 4d8:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <rcv_valid>
			start_bit = 1;
 4dc:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <start_bit>
			tx_char = rcv_char;
 4e0:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <rcv_char>
 4e4:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <tx_char>
			tx_bit_count = 0;
 4e8:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <tx_bit_count>
			sending = 1;
 4ec:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <sending>
			TCNT0 = 0x00;						//reset counter to avoid glitch on next rcv char.
 4f0:	16 bc       	out	0x26, r1	; 38
			TIMSK0 |= (1<<OCIE0A);		           //if you want interrupt
 4f2:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
 4f6:	82 60       	ori	r24, 0x02	; 2
 4f8:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
 4fc:	e9 cf       	rjmp	.-46     	; 0x4d0 <main+0xba>

000004fe <__vector_12>:



//watchdog timer
ISR (TIMER0_COMPA_vect)
{
 4fe:	1f 92       	push	r1
 500:	0f 92       	push	r0
 502:	0f b6       	in	r0, 0x3f	; 63
 504:	0f 92       	push	r0
 506:	11 24       	eor	r1, r1
 508:	2f 93       	push	r18
 50a:	3f 93       	push	r19
 50c:	4f 93       	push	r20
 50e:	5f 93       	push	r21
 510:	8f 93       	push	r24
 512:	9f 93       	push	r25
	/*disable interrupts, should we or allow NMI of tamper switch detect? */
	//cli();
	//sei();
	TCNT0 = 0x00;
 514:	16 bc       	out	0x26, r1	; 38
	int i;
	PORTC ^= _BV(PORTC6);		//toggle gp6 to check on progress
 516:	9a b1       	in	r25, 0x0a	; 10
 518:	80 e4       	ldi	r24, 0x40	; 64
 51a:	89 27       	eor	r24, r25
 51c:	8a b9       	out	0x0a, r24	; 10
	if (receiving) {
 51e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <receiving>
 522:	88 23       	and	r24, r24
 524:	49 f0       	breq	.+18     	; 0x538 <__vector_12+0x3a>
		if (start_bit)	{
 526:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <start_bit>
 52a:	88 23       	and	r24, r24
 52c:	79 f1       	breq	.+94     	; 0x58c <__vector_12+0x8e>
			start_bit--;
 52e:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <start_bit>
 532:	81 50       	subi	r24, 0x01	; 1
 534:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <start_bit>
				receiving = 0;
			}
			rcv_bit_count--;
		}
	}
	if (sending){
 538:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <sending>
 53c:	88 23       	and	r24, r24
 53e:	d9 f0       	breq	.+54     	; 0x576 <__vector_12+0x78>
		if (start_bit == 1)	{
 540:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <start_bit>
 544:	81 30       	cpi	r24, 0x01	; 1
 546:	09 f4       	brne	.+2      	; 0x54a <__vector_12+0x4c>
 548:	54 c0       	rjmp	.+168    	; 0x5f2 <__vector_12+0xf4>
			start_bit = 0;
			PORTB &= ~_BV(PORTB2);  //PORTB3 to PORTB2
		}
		else {
			if (tx_bit_count<8){
 54a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <tx_bit_count>
 54e:	88 30       	cpi	r24, 0x08	; 8
 550:	d8 f5       	brcc	.+118    	; 0x5c8 <__vector_12+0xca>
				if (rcv_char & (1<<tx_bit_count)){  //check the bit sending LSB first
 552:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <rcv_char>
 556:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <tx_bit_count>
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	02 c0       	rjmp	.+4      	; 0x562 <__vector_12+0x64>
 55e:	95 95       	asr	r25
 560:	87 95       	ror	r24
 562:	2a 95       	dec	r18
 564:	e2 f7       	brpl	.-8      	; 0x55e <__vector_12+0x60>
 566:	80 ff       	sbrs	r24, 0
 568:	3d c0       	rjmp	.+122    	; 0x5e4 <__vector_12+0xe6>
					PORTB |= _BV(PORTB2);
 56a:	32 9a       	sbi	0x06, 2	; 6
				PORTB |= _BV(PORTB2);        //send stop bit
				TIMSK0 &= ~(1<<OCIE0A);		//stop the bit timer
				sending = 0;
				PORTC |= _BV(PORTC6);
			}
			tx_bit_count++;
 56c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <tx_bit_count>
 570:	8f 5f       	subi	r24, 0xFF	; 255
 572:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <tx_bit_count>
		
	}
	//
	//sei();
	
 576:	9f 91       	pop	r25
 578:	8f 91       	pop	r24
 57a:	5f 91       	pop	r21
 57c:	4f 91       	pop	r20
 57e:	3f 91       	pop	r19
 580:	2f 91       	pop	r18
 582:	0f 90       	pop	r0
 584:	0f be       	out	0x3f, r0	; 63
 586:	0f 90       	pop	r0
 588:	1f 90       	pop	r1
 58a:	18 95       	reti
		if (start_bit)	{
			start_bit--;
			//skip first bit
		}
		else {	
			if (rcv_bit_count-1 > 0) {     //looking for data) 
 58c:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rcv_bit_count>
 590:	90 e0       	ldi	r25, 0x00	; 0
 592:	02 97       	sbiw	r24, 0x02	; 2
 594:	94 f1       	brlt	.+100    	; 0x5fa <__vector_12+0xfc>
				rcv_char |= ((PINB & (1<<3))>>3)<<(9-rcv_bit_count);  //from (1<<2) to (1<<3)
 596:	84 b1       	in	r24, 0x04	; 4
 598:	50 91 0d 01 	lds	r21, 0x010D	; 0x80010d <rcv_bit_count>
 59c:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <rcv_char>
 5a0:	83 fb       	bst	r24, 3
 5a2:	22 27       	eor	r18, r18
 5a4:	20 f9       	bld	r18, 0
 5a6:	89 e0       	ldi	r24, 0x09	; 9
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	85 1b       	sub	r24, r21
 5ac:	91 09       	sbc	r25, r1
 5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <__vector_12+0xb4>
 5b0:	22 0f       	add	r18, r18
 5b2:	8a 95       	dec	r24
 5b4:	ea f7       	brpl	.-6      	; 0x5b0 <__vector_12+0xb2>
 5b6:	24 2b       	or	r18, r20
 5b8:	20 93 09 01 	sts	0x0109, r18	; 0x800109 <rcv_char>
				PCMSK1 |= _BV(PCINT11);		//enable start bit detect INT10 to INT11
				//PCICR |= _BV(PCIE1);
				PORTC |= _BV(PORTC6);
				receiving = 0;
			}
			rcv_bit_count--;
 5bc:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rcv_bit_count>
 5c0:	81 50       	subi	r24, 0x01	; 1
 5c2:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <rcv_bit_count>
 5c6:	b8 cf       	rjmp	.-144    	; 0x538 <__vector_12+0x3a>
				}
				else{
					PORTB &= ~_BV(PORTB2);
				}
			}
			else if (tx_bit_count == 8){
 5c8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <tx_bit_count>
 5cc:	88 30       	cpi	r24, 0x08	; 8
 5ce:	71 f6       	brne	.-100    	; 0x56c <__vector_12+0x6e>
				PORTB |= _BV(PORTB2);        //send stop bit
 5d0:	32 9a       	sbi	0x06, 2	; 6
				TIMSK0 &= ~(1<<OCIE0A);		//stop the bit timer
 5d2:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
 5d6:	8d 7f       	andi	r24, 0xFD	; 253
 5d8:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
				sending = 0;
 5dc:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <sending>
				PORTC |= _BV(PORTC6);
 5e0:	56 9a       	sbi	0x0a, 6	; 10
 5e2:	c4 cf       	rjmp	.-120    	; 0x56c <__vector_12+0x6e>
			if (tx_bit_count<8){
				if (rcv_char & (1<<tx_bit_count)){  //check the bit sending LSB first
					PORTB |= _BV(PORTB2);
				}
				else{
					PORTB &= ~_BV(PORTB2);
 5e4:	32 98       	cbi	0x06, 2	; 6
				PORTB |= _BV(PORTB2);        //send stop bit
				TIMSK0 &= ~(1<<OCIE0A);		//stop the bit timer
				sending = 0;
				PORTC |= _BV(PORTC6);
			}
			tx_bit_count++;
 5e6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <tx_bit_count>
 5ea:	8f 5f       	subi	r24, 0xFF	; 255
 5ec:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <tx_bit_count>
 5f0:	c2 cf       	rjmp	.-124    	; 0x576 <__vector_12+0x78>
			rcv_bit_count--;
		}
	}
	if (sending){
		if (start_bit == 1)	{
			start_bit = 0;
 5f2:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <start_bit>
			PORTB &= ~_BV(PORTB2);  //PORTB3 to PORTB2
 5f6:	32 98       	cbi	0x06, 2	; 6
 5f8:	be cf       	rjmp	.-132    	; 0x576 <__vector_12+0x78>
		else {	
			if (rcv_bit_count-1 > 0) {     //looking for data) 
				rcv_char |= ((PINB & (1<<3))>>3)<<(9-rcv_bit_count);  //from (1<<2) to (1<<3)
				//rcv[9-rcv_bit_count] = (PINB & (1<<3))>>3;
			}
			else if (rcv_bit_count == 0) {  //looking for stop bit
 5fa:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rcv_bit_count>
 5fe:	81 11       	cpse	r24, r1
 600:	dd cf       	rjmp	.-70     	; 0x5bc <__vector_12+0xbe>
				if (PINB & (1<<PINB3)) {    //PINB2 to PINB3
					rcv_valid = 1;
 602:	81 e0       	ldi	r24, 0x01	; 1
			if (rcv_bit_count-1 > 0) {     //looking for data) 
				rcv_char |= ((PINB & (1<<3))>>3)<<(9-rcv_bit_count);  //from (1<<2) to (1<<3)
				//rcv[9-rcv_bit_count] = (PINB & (1<<3))>>3;
			}
			else if (rcv_bit_count == 0) {  //looking for stop bit
				if (PINB & (1<<PINB3)) {    //PINB2 to PINB3
 604:	23 9b       	sbis	0x04, 3	; 4
 606:	14 c0       	rjmp	.+40     	; 0x630 <__vector_12+0x132>
					rcv_valid = 1;
 608:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <rcv_valid>
					AVR_LED_PORT ^= _BV(AVR_LED_RED_BIT);
 60c:	92 b1       	in	r25, 0x02	; 2
 60e:	88 e0       	ldi	r24, 0x08	; 8
 610:	89 27       	eor	r24, r25
 612:	82 b9       	out	0x02, r24	; 2
				}
				else {
					rcv_error_stop = 1;
				}
				TIMSK0 &= ~(1<<OCIE0A);		//stop the bit timer
 614:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
 618:	8d 7f       	andi	r24, 0xFD	; 253
 61a:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
				PCMSK1 |= _BV(PCINT11);		//enable start bit detect INT10 to INT11
 61e:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
 622:	88 60       	ori	r24, 0x08	; 8
 624:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
				//PCICR |= _BV(PCIE1);
				PORTC |= _BV(PORTC6);
 628:	56 9a       	sbi	0x0a, 6	; 10
				receiving = 0;
 62a:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <receiving>
 62e:	c6 cf       	rjmp	.-116    	; 0x5bc <__vector_12+0xbe>
				if (PINB & (1<<PINB3)) {    //PINB2 to PINB3
					rcv_valid = 1;
					AVR_LED_PORT ^= _BV(AVR_LED_RED_BIT);
				}
				else {
					rcv_error_stop = 1;
 630:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 634:	ef cf       	rjmp	.-34     	; 0x614 <__vector_12+0x116>

00000636 <_exit>:
 636:	f8 94       	cli

00000638 <__stop_program>:
 638:	ff cf       	rjmp	.-2      	; 0x638 <__stop_program>
